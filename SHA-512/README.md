# SHA-512 Custom Computer System
## Project Description
- The purpose of this project was to design a custom computer system for the SHA-512 algorithm. This was done as my final project for a Digital Computer Design class, and was a semester-long project. The goal of the project was to emulate SHA-512 on a De1_SoC Intel FPGA board, using the Rhody System we had built during our labs. An important note about the Rhody System is that it uses 32 bit registers, not 64 bit, hence the need to emulate SHA-512. Also note that the Rhody System has three different versions: basic, pipelined, and pipelined with branch prediction. All the modifications for this project are located in "RHODY_CPU_PIPE_BP.vhd". This version of the CPU is the fastest, hence the modifications to the system being in that version. The Rhody System can be interacted with through the custom Rhody assembly language, as can be seen in "SHA-512.asm". Our professor educated us on this version of assembly he had created for the system. 
- The target for this project was to reach 2000 hashes per second, and my version attained 5127 hashes per second. This was done by performing the majority of tasks executed during the SHA-512 algorithm in VHDL rather than the assembly. To accomplish this I had to add several instructions to the pre-existing language: "ADD64", "SUM0", "SUM1", "SIG0", "SIG1", "MAJ", "CH", "SCH3", "SCH4", "SCH50", "SCH51", and "S64", and define them in VHDL. Of these, six are logic functons: "SUM0", "SUM1", "SIG0", "SIG1", "MAJ", and "CH". The 64-bit version of these logic instructions had been given to us by our professor upon completing the 32-bit versions ourselves. The translation of these instructions from functions in assembly to instructions in VHDL yielded massive performance gains. A brief description of these instructions: "ADD64" combines input from four registers, adds them, and the concatenates the answer into a 64 bit number, with the upper half and lower half in two separate registers. "SCH3" sets predefined "working" variables (temps) to the initial hash values. "SCH4" utilized many of the above logic functions to perform part of the needed hash computations. Both "SCH50" and "SCH51" perform the last part of the hash computations by combining the results from SCH4 with each corresponding initial hash value. Lastly, "S64" was a special store instruction I created that is capable of storing 64 bits worth of data to memory. The instruction takes a memory target as input, as well as two registers. The first register's value is stored at the specified memory location, and the second register's value is stored at the specified memory location + 1. 
